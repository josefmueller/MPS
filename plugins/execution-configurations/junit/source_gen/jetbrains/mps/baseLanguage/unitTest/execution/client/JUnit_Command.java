package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.io.File;
import com.intellij.execution.process.ProcessHandler;
import java.util.List;
import jetbrains.mps.baseLanguage.execution.api.JavaRunParameters;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.baseLanguage.execution.api.Java_Command;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.debug.api.IDebugger;
import jetbrains.mps.baseLanguage.unitTest.execution.server.ExecutorScript;
import jetbrains.mps.tool.common.ScriptData;
import jetbrains.mps.tool.common.RepositoryDescriptor;
import java.util.Set;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.HashSet;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.vfs.IFile;
import org.jdom.Element;
import jetbrains.mps.tool.common.JDOMUtil;
import org.jdom.Document;
import java.io.IOException;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedList;
import java.net.URL;
import jetbrains.mps.core.tool.environment.classloading.ClassloaderUtil;
import java.net.URISyntaxException;
import com.intellij.openapi.application.PathManager;
import jetbrains.mps.debug.api.run.IDebuggerConfiguration;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.debug.api.IDebuggerSettings;
import jetbrains.mps.debugger.java.api.settings.LocalConnectionSettings;
import jetbrains.mps.debug.api.Debuggers;

public class JUnit_Command {
  private static final Logger LOG = LogManager.getLogger(JUnit_Command.class);
  private String myDebuggerSettings_String;
  private String myVirtualMachineParameter_String;
  private String myJrePath_String;
  private File myWorkingDirectory_File = new File(".");
  public JUnit_Command() {
  }
  public JUnit_Command setDebuggerSettings_String(String debuggerSettings) {
    if (debuggerSettings != null) {
      myDebuggerSettings_String = debuggerSettings;
    }
    return this;
  }
  public JUnit_Command setVirtualMachineParameter_String(String virtualMachineParameter) {
    if (virtualMachineParameter != null) {
      myVirtualMachineParameter_String = virtualMachineParameter;
    }
    return this;
  }
  public JUnit_Command setJrePath_String(String jrePath) {
    if (jrePath != null) {
      myJrePath_String = jrePath;
    }
    return this;
  }
  public JUnit_Command setWorkingDirectory_File(File workingDirectory) {
    if (workingDirectory != null) {
      myWorkingDirectory_File = workingDirectory;
    }
    return this;
  }

  public ProcessHandler createProcess(List<ITestNodeWrapper> tests, JavaRunParameters javaRunParameters) throws ExecutionException {
    return new JUnit_Command().setVirtualMachineParameter_String(check_txeh3_a1a0a0a(javaRunParameters)).setJrePath_String((check_txeh3_a0c0a0a0(javaRunParameters) ? javaRunParameters.jrePath() : null)).setWorkingDirectory_File((isEmptyString(check_txeh3_a0a3a0a0a(javaRunParameters)) ? null : new File(javaRunParameters.workingDirectory()))).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(tests);
  }
  public ProcessHandler createProcess(List<ITestNodeWrapper> tests) throws ExecutionException {
    if (tests == null) {
      throw new ExecutionException("Tests to run are null.");
    }
    List<ITestNodeWrapper> testsNoNull = ListSequence.fromList(tests).where(new NotNullWhereFilter<ITestNodeWrapper>()).toListSequence();
    if (ListSequence.fromList(testsNoNull).isEmpty()) {
      throw new ExecutionException("No tests to run");
    }
    TestsWithParameters testsToRun = JUnit_Command.getTestsToRunWithParameters(testsNoNull);
    if (ListSequence.fromList(tests).isEmpty()) {
      throw new ExecutionException("Could not find tests to run.");
    }
    // FIXME use of global repository here is just provisional, we need an MPS project here (it's fine to demand an MPS project when we launch MPS tests from within an IDE, right?) 
    SRepository repo = MPSModuleRepository.getInstance();
    return new Java_Command().setVirtualMachineParameter_String(IterableUtils.join(ListSequence.fromList(testsToRun.getParameters().getJvmArgs()), " ") + (((myVirtualMachineParameter_String != null && myVirtualMachineParameter_String.length() > 0) ? " " + myVirtualMachineParameter_String : ""))).setClassPath_ListString(ListSequence.fromList(JUnit_Command.getClasspath(testsToRun, repo)).toListSequence()).setJrePath_String(myJrePath_String).setWorkingDirectory_File(myWorkingDirectory_File).setProgramParameter_String(JUnit_Command.getProgramParameters(testsToRun, repo)).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(testsToRun.getParameters().getExecutorClass().getName());
  }

  public static IDebugger getDebugger() {
    return getDebuggerConfiguration().getDebugger();
  }

  private static String getProgramParameters(final TestsWithParameters testsToRun, final SRepository repo) throws ExecutionException {
    if (testsToRun.getParameters().needsMPS()) {
      ExecutorScript args = new ExecutorScript();
      ScriptData startupArgs = args.addStartupArguments();
      final RepositoryDescriptor rd = new RepositoryDescriptor();
      // I've got set of reference to modules I need to present in a new MPS instance 
      // and now have to guess their locations to pass to the new instance. 
      // XXX here, we exploit the assumption module descriptor file resides under a module root 
      repo.getModelAccess().runReadAction(new Runnable() {
        public void run() {
          Set<SModule> modules = new HashSet<SModule>();
          for (SModuleReference testModule : testsToRun.getRequiredModules()) {
            SModule tm = testModule.resolve(repo);
            if (tm != null) {
              modules.add(tm);
            }
          }
          GlobalModuleDependenciesManager gmdm = new GlobalModuleDependenciesManager(modules);
          Collection<SModule> execClosure = gmdm.getModules(GlobalModuleDependenciesManager.Deptype.EXECUTE);
          for (SModule m : CollectionSequence.fromCollection(execClosure)) {
            if (false == m instanceof AbstractModule) {
              continue;
            }
            IFile descriptorFile = ((AbstractModule) m).getDescriptorFile();
            if (descriptorFile == null) {
              continue;
            }
            // XXX in fact, for non-deployed module this would end up with a module source dir, which is not 'file' per se, but as long as there's 
            // no distinction in processing rd.files and rd.folders (ModulesMiner doesn't care), I don't bother here either. 
            rd.files.add(descriptorFile.getBundleHome().getPath());
          }
        }
      });
      startupArgs.setRepo(rd);
      // startupArgs.addPlugin() 
      startupArgs.setLoadBootstrapLibraries(true);
      // XXX May want to pass value of idea.additional.classpath system property further to new IdeaApplication instance to ensure plugins that are  
      // loaded from sources could get loaded in the new application as well. 
      for (ITestNodeWrapper test : ListSequence.fromList(testsToRun.getTests())) {
        args.addTest(test);
      }
      try {
        File tempFile = File.createTempFile("test-exec", ".xml");
        tempFile.deleteOnExit();
        Element root = new Element("tests-exec");
        args.write(root);
        JDOMUtil.writeDocument(new Document(root), tempFile);
        return tempFile.getAbsolutePath();
      } catch (IOException ex) {
        throw new ExecutionException("Failed to prepare arguments for test executor", ex);
      }
    } else {
      List<String> testsCommandLine = ListSequence.fromList(new ArrayList<String>(ListSequence.fromList(testsToRun.getTests()).count() * 2));
      for (ITestNodeWrapper test : ListSequence.fromList(testsToRun.getTests())) {
        ListSequence.fromList(testsCommandLine).addElement((test.isTestCase() ? "-c" : "-m"));
        ListSequence.fromList(testsCommandLine).addElement(test.getFqName());
      }
      return IterableUtils.join(ListSequence.fromList(testsCommandLine), " ");
    }
  }
  private static TestsWithParameters getTestsToRunWithParameters(@NotNull List<ITestNodeWrapper> tests) throws ExecutionException {
    TestParameters runParams = JUnit_Command.getMaxParams(tests);
    List<ITestNodeWrapper> testsToRun = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    List<ITestNodeWrapper> testsToSkip = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    for (ITestNodeWrapper test : ListSequence.fromList(tests)) {
      TestParameters testRunParameters = test.getTestRunParameters();
      if (runParams.comprises(testRunParameters)) {
        ListSequence.fromList(testsToRun).addElement(test);
      } else {
        ListSequence.fromList(testsToSkip).addElement(test);
      }
    }
    String skipped = IterableUtils.join(ListSequence.fromList(testsToSkip).select(new ISelector<ITestNodeWrapper, String>() {
      public String select(ITestNodeWrapper it) {
        return it.getName();
      }
    }), " ");
    if ((skipped != null && skipped.length() > 0)) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("All tests could not be executed together. Skipped: " + skipped);
      }
    }
    Set<SModuleReference> uniqueModules = SetSequence.fromSet(new HashSet<SModuleReference>());
    for (ITestNodeWrapper tt : tests) {
      SetSequence.fromSet(uniqueModules).addElement(tt.getTestNodeModule());
    }
    return new TestsWithParameters(testsToRun, runParams, uniqueModules);
  }
  private static TestParameters getMaxParams(List<ITestNodeWrapper> tests) {
    TestParameters maxParams = ListSequence.fromList(tests).first().getTestRunParameters();
    for (ITestNodeWrapper test : ListSequence.fromList(tests)) {
      TestParameters newRunParams = test.getTestRunParameters();
      if (newRunParams.comprises(maxParams)) {
        maxParams = newRunParams;
      }
    }
    return maxParams;
  }
  private static List<String> getClasspath(final TestsWithParameters tests, final SRepository repo) {
    final List<String> classpath = ListSequence.fromList(new LinkedList<String>());
    if (tests.getParameters().needsMPS()) {
      ListSequence.fromList(classpath).addSequence(ListSequence.fromList(JUnit_Command.collectFromLibFolder()).distinct());
      ListSequence.fromList(classpath).addSequence(ListSequence.fromList(JUnit_Command.collectFromPreInstalledPluginsFolder()).distinct());
      // Module classpath would get managed by IdeaEnvironment based on set of modules to load 
    } else {
      // when no MPS is started, we just build a regular Java classpath with everything test classes may need. 
      repo.getModelAccess().runReadAction(new Runnable() {
        public void run() {
          Set<SModule> uniqueModules = SetSequence.fromSet(new HashSet<SModule>());
          for (SModuleReference testModule : tests.getRequiredModules()) {
            SModule module = testModule.resolve(repo);
            if (module != null) {
              SetSequence.fromSet(uniqueModules).addElement(module);
            } else {
              String m = String.format("No test module %s is available, execution classpath may be invalid.", testModule.getModuleName());
              if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn(m);
              }
            }
          }
          ListSequence.fromList(classpath).addSequence(ListSequence.fromList(Java_Command.getClasspath(uniqueModules)));
        }
      });
    }
    return ListSequence.fromList(tests.getParameters().getClassPath()).union(ListSequence.fromList(classpath)).toListSequence();
  }
  private static List<String> collectFromLibFolder() {
    List<URL> urls = ListSequence.fromList(new ArrayList<URL>());
    ClassloaderUtil.addIDEALibraries(urls);
    // FIXME Look, this is stupid. First, we collect library location as files, then translate them to toURI().toURL() only to get File path back here. 
    List<String> rv = ListSequence.fromList(new ArrayList<String>(ListSequence.fromList(urls).count()));
    for (URL u : ListSequence.fromList(urls)) {
      // NOTE, URL.getPath() gives URL segment with escaped characters (e.g. %20), therefore we resort to toURI to get them unescaped. 
      try {
        ListSequence.fromList(rv).addElement(u.toURI().getPath());
      } catch (URISyntaxException ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Bad library location", ex);
        }
      }
    }
    return rv;
  }
  private static List<String> collectFromPreInstalledPluginsFolder() {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    File preinstalledFolder = new File(PathManager.getPreInstalledPluginsPath());
    final File[] pluginFiles = preinstalledFolder.listFiles();
    if (pluginFiles != null) {
      for (final File pluginFile : pluginFiles) {
        if (!(ClassloaderUtil.isJarOrZip(pluginFile))) {
          File classesDir = new File(pluginFile, "classes");
          if (classesDir.exists()) {
            ListSequence.fromList(result).addElement(classesDir.getAbsolutePath());
          }
          File libDir = new File(pluginFile, "lib");
          if (libDir.exists()) {
            ListSequence.fromList(result).addSequence(ListSequence.fromList(JUnit_Command.allJarsUnderRoot(libDir)));
          }
        }
      }
    }
    ListSequence.fromList(result).addSequence(ListSequence.fromList(JUnit_Command.allJarsUnderRoot(preinstalledFolder)));
    return result;
  }
  private static List<String> allJarsUnderRoot(File root) {
    List<String> res = ListSequence.fromList(new ArrayList<String>());
    File[] children = root.listFiles();
    if (children != null) {
      for (final File childFile : children) {
        if (ClassloaderUtil.isJarOrZip(childFile)) {
          ListSequence.fromList(res).addElement(childFile.getAbsolutePath());
        }
      }
    }

    return res;
  }

  public static IDebuggerConfiguration getDebuggerConfiguration() {
    return new IDebuggerConfiguration() {
      @Nullable
      public IDebuggerSettings createDebuggerSettings() {
        return new LocalConnectionSettings(true);
      }
      public IDebugger getDebugger() {
        return Debuggers.getInstance().getDebuggerByName("Java");
      }
    };
  }
  private static String check_txeh3_a1a0a0a(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.vmOptions();
    }
    return null;
  }
  private static boolean check_txeh3_a0c0a0a0(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return (boolean) checkedDotOperand.useAlternativeJre();
    }
    return false;
  }
  private static String check_txeh3_a0a3a0a0a(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }
  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }
}
