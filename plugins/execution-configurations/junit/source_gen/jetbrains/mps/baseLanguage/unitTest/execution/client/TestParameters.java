package jetbrains.mps.baseLanguage.unitTest.execution.client;

/*Generated by MPS */

import org.jetbrains.mps.annotations.Immutable;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.baseLanguage.execution.api.Java_Command;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.unitTest.execution.server.DefaultTestExecutor;

@Immutable
public final class TestParameters {
  private final Class<?> myExecutorClass;
  private final List<String> myClassPath;
  private final List<String> myAdditionalJvmArgs;
  private final boolean myNeedsMPS;

  public TestParameters(Class<?> executorClass, List<String> classPath, List<String> jvmArgs) {
    this(executorClass, false, classPath, jvmArgs);
  }

  public TestParameters(Class<?> executorClass, List<String> classPath) {
    this(executorClass, false, classPath, ListSequence.fromList(new LinkedList<String>()));
  }

  public TestParameters(Class<?> executorClass, boolean mpsRequired, @Nullable List<String> classPath, @Nullable List<String> jvmArgs) {
    myExecutorClass = executorClass;
    myClassPath = (classPath == null ? LinkedListSequence.fromLinkedListNew(new LinkedList<String>()) : classPath);
    myAdditionalJvmArgs = (jvmArgs == null ? LinkedListSequence.fromLinkedListNew(new LinkedList<String>()) : jvmArgs);
    myNeedsMPS = mpsRequired;
  }

  public Class<?> getExecutorClass() {
    return myExecutorClass;
  }

  public List<String> getJvmArgs() {
    return ListSequence.fromList(myAdditionalJvmArgs).asUnmodifiable();
  }

  public List<String> getClassPath() {
    return ListSequence.fromList(myClassPath).asUnmodifiable();
  }

  public boolean comprises(@NotNull TestParameters other) {
    if (this == other) {
      return true;
    }
    if (other.getExecutorClass().isAssignableFrom(getExecutorClass())) {
      if (!(myNeedsMPS) && other.myNeedsMPS) {
        // tests that don't need MPS can run from within MPS instance, but not other way round. 
        return false;
      }
      if (ListSequence.fromList(myClassPath).containsSequence(ListSequence.fromList(other.getClassPath()))) {
        if (ListSequence.fromList(myAdditionalJvmArgs).containsSequence(ListSequence.fromList(other.getJvmArgs()))) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * 
   * @return {@code true} if tests need a running MPS instance to get executed.
   */
  public boolean needsMPS() {
    return myNeedsMPS;
  }

  public static TestParameters calcDefault(final SRepository repo) {
    List<String> classPath = new ModelAccessHelper(repo).runReadAction(new Computable<List<String>>() {
      public List<String> compute() {
        SModule m = PersistenceFacade.getInstance().createModuleReference("f618e99a-2641-465c-bb54-31fe76f9e285(jetbrains.mps.baseLanguage.unitTest.execution)").resolve(repo);
        return Java_Command.getClasspath(Sequence.<SModule>singleton(m));
      }
    });
    return new TestParameters(DefaultTestExecutor.class, classPath);
  }
}
