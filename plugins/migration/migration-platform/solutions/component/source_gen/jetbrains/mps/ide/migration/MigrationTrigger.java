package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.migration.global.MigrationOptions;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.MPSCoreComponents;
import jetbrains.mps.ide.platform.watching.ReloadManagerComponent;
import java.util.concurrent.atomic.AtomicInteger;
import jetbrains.mps.RuntimeFlags;
import com.intellij.openapi.startup.StartupManager;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.smodel.SLanguageHierarchy;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Set;
import java.util.LinkedHashSet;
import java.util.Collection;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.smodel.RepoListenerRegistrar;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.smodel.Language;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.intellij.openapi.application.ModalityState;
import jetbrains.mps.ide.migration.wizard.MigrationWizard;
import jetbrains.mps.ide.migration.wizard.MigrationError;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import jetbrains.mps.errors.item.IssueKindReportItem;
import java.util.ArrayList;
import jetbrains.mps.migration.global.MigrationProblemHandler;
import com.intellij.openapi.application.Application;
import com.intellij.util.WaitForProgressToShow;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.ide.platform.watching.ReloadListener;
import org.jetbrains.mps.openapi.module.SRepositoryContentAdapter;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.event.SModelEventVisitor;
import jetbrains.mps.smodel.event.SModelEventVisitorAdapter;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.ModelsEventsCollector;
import jetbrains.mps.smodel.event.SModelEvent;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.classloading.MPSClassesListenerAdapter;
import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.ide.migration.wizard.MigrationSession;

/**
 * At the first startup, migration is not required
 * The need for migration is determined after startup by checking all modules once and then watching the repo
 * Whether some change requires migration to be executed, the user is notified about that and the project is reloaded
 * with myState.migrationRequired set to true.
 * In this case, the migration is executed and no watchers are added (as they could try to run the migration once again)
 * After the migration is completed, myState.migrationRequired is set to false again and the project is reloaded
 * 
 * Reasons to reload project after migration:
 * 1. The reload cycle with migration wizard happens w/o adding repo listeners
 * 2. Models should be unloaded after migration
 */
@State(name = "MigrationTrigger", storages = @Storage(value = StoragePathMacros.WORKSPACE_FILE)
)
public class MigrationTrigger extends AbstractProjectComponent implements IStartupMigrationExecutor {
  private final ClassLoaderManager myClassLoaderManager;
  private MigrationOptions myOptions = new MigrationOptions();

  private final MPSProject myMpsProject;
  private final MigrationRegistry myMigrationRegistry;
  private final ReloadManager myReloadManager;

  private boolean myMigrationQueued = false;

  private ProjectMigrationProperties myProperties;

  private MigrationTrigger.MyRepoListener myRepoListener = new MigrationTrigger.MyRepoListener();
  private MigrationTrigger.MyReloadListener myReloadListener = new MigrationTrigger.MyReloadListener();
  private MigrationTrigger.MyClassesListener myClassesListener = new MigrationTrigger.MyClassesListener();
  private MigrationTrigger.MyPropertiesListener myPropertiesListener = new MigrationTrigger.MyPropertiesListener();
  private boolean myListenersAdded = false;

  public MigrationTrigger(Project ideaProject, MPSProject p, MigrationRegistry migrationManager, ProjectMigrationProperties props, MPSCoreComponents mpsCore, ReloadManagerComponent reloadManager) {
    super(ideaProject);
    myMpsProject = p;
    myMigrationRegistry = migrationManager;
    myProperties = props;
    myClassLoaderManager = mpsCore.getClassLoaderManager();
    myReloadManager = reloadManager;
  }

  private final AtomicInteger myBlocked = new AtomicInteger(0);

  public void blockMigrationsCheck() {
    myBlocked.incrementAndGet();
  }

  public void unblockMigrationsCheck() {
    int locks = myBlocked.decrementAndGet();
    assert locks >= 0 : "Non-paired block-unblock method usage";
    if (locks == 0) {
      checkMigrationNeeded();
    }
  }

  public void projectOpened() {
    // this is a hack for migration task purposes 
    if (RuntimeFlags.getTestMode().isInsideTestEnvironment()) {
      return;
    }

    // wait until project is fully loaded (if not yet) 
    StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            initModuleVersionsWhereNeeded();

            addListeners();
            checkMigrationNeeded();
          }
        });
      }
    });
  }

  private void initModuleVersionsWhereNeeded() {
    myMpsProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        for (SModule m : ListSequence.fromList(myMpsProject.getProjectModulesWithGenerators())) {
          if (!((m instanceof AbstractModule))) {
            continue;
          }

          // this code should be removed when we are sure there are no modules without language  
          // version information persisted 
          // this code should be executed when all models are already there in the module to  
          // produce a correct list of used languages 
          ModuleDescriptor desc = ((AbstractModule) m).getModuleDescriptor();
          if (!(desc.hasLanguageVersions())) {
            SLanguageHierarchy languageHierarchy = new SLanguageHierarchy(m.getUsedLanguages());
            for (SLanguage lang : languageHierarchy.getExtended()) {
              if (desc.getLanguageVersions().containsKey(lang)) {
                continue;
              }
              desc.getLanguageVersions().put(lang, 0);
            }
            desc.setHasLanguageVersions(true);
            ((AbstractModule) m).setChanged();
          }
          if (!(desc.hasDependencyVersions())) {
            Set<SModule> visible = new LinkedHashSet<SModule>();
            visible.add(m);
            Collection<SModule> dependentModules = new GlobalModuleDependenciesManager(m).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE);
            visible.addAll(dependentModules);
            for (SModule dep : visible) {
              if (desc.getDependencyVersions().containsKey(dep.getModuleReference())) {
                continue;
              }
              desc.getDependencyVersions().put(dep.getModuleReference(), 0);
            }
            desc.setHasDependencyVersions(true);
            ((AbstractModule) m).setChanged();
          }
        }
      }
    });
  }

  public void projectClosed() {
    removeListeners();
  }

  private void addListeners() {
    myListenersAdded = true;
    new RepoListenerRegistrar(myMpsProject.getRepository(), myRepoListener).attach();
    myClassLoaderManager.addClassesHandler(this.myClassesListener);
    myProperties.addListener(myPropertiesListener);
    myReloadManager.addReloadListener(myReloadListener);
  }

  private boolean removeListeners() {
    if (!(myListenersAdded)) {
      return true;
    }
    myProperties.removeListener(myPropertiesListener);
    myClassLoaderManager.removeClassesHandler(myClassesListener);
    new RepoListenerRegistrar(myMpsProject.getRepository(), myRepoListener).detach();
    myReloadManager.removeReloadListener(myReloadListener);
    return false;
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "MigrationTrigger";
  }

  public synchronized void resetMigrationQueuedFlag() {
    myMigrationQueued = false;
  }

  /*package*/ void checkMigrationNeeded() {
    myMpsProject.getRepository().getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        checkMigrationNeededOnModuleChange(MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject));
      }
    });
  }

  private synchronized void checkMigrationNeededOnModuleChange(Iterable<SModule> modules) {
    if (myMigrationQueued) {
      return;
    }
    Set<SModule> modules2Check = SetSequence.fromSetWithValues(new HashSet<SModule>(), modules);
    if (myMigrationRegistry.importVersionsUpdateRequired(modules2Check) || CollectionSequence.fromCollection(myMigrationRegistry.getModuleMigrations(modules2Check)).isNotEmpty() || CollectionSequence.fromCollection(myMigrationRegistry.getProjectMigrations()).isNotEmpty()) {
      postponeMigration();
    }
  }

  private synchronized void checkMigrationNeededOnLanguageReload(Iterable<Language> languages) {
    if (myMigrationQueued) {
      return;
    }

    // if a new language is added to a repo, all modules in project using it  
    // should be checked for whether their migration is needed  
    final Set<SModule> modules2Check = SetSequence.fromSet(new HashSet<SModule>());
    final List<SLanguage> addedLanguages = Sequence.fromIterable(languages).select(new ISelector<Language, SLanguage>() {
      public SLanguage select(Language it) {
        return MetaAdapterFactory.getLanguage(it.getModuleReference());
      }
    }).toListSequence();
    Sequence.fromIterable(MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        Set<SLanguage> used = new HashSet<SLanguage>(it.getUsedLanguages());
        used.retainAll(addedLanguages);
        if (!(used.isEmpty())) {
          SetSequence.fromSet(modules2Check).addElement(it);
        }
      }
    });
    if (myMigrationRegistry.importVersionsUpdateRequired(modules2Check) || CollectionSequence.fromCollection(myMigrationRegistry.getModuleMigrations(modules2Check)).isNotEmpty()) {
      postponeMigration();
    }
  }

  public synchronized void postponeMigration() {
    if (myBlocked.get() != 0) {
      return;
    }

    final Project ideaProject = myProject;
    myMigrationQueued = true;

    // wait until project is fully loaded (if not yet) 
    StartupManager.getInstance(ideaProject).runWhenProjectIsInitialized(new Runnable() {
      public void run() {
        // as we use ui, postpone to EDT 
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            ProgressManager.getInstance().run(new Task.Modal(ideaProject, "Synchronizing Files...", false) {
              public void run(@NotNull ProgressIndicator pi) {
                pi.setIndeterminate(true);
                myReloadManager.flush();
                syncRefresh();
              }
            });

            final Wrappers._boolean resave = new Wrappers._boolean();
            final Wrappers._boolean migrate = new Wrappers._boolean();
            myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
              public void run() {
                resave.value = myMigrationRegistry.importVersionsUpdateRequired(MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject));
                migrate.value = myMigrationRegistry.isMigrationRequired();
              }
            });

            if (resave.value || migrate.value) {
              startMigration(resave.value, migrate.value);
            } else {
              resetMigrationQueuedFlag();
            }
          }
        }, ModalityState.NON_MODAL);
      }
    });
  }

  private void startMigration(boolean update, boolean migrate) {
    MigrationTrigger.MyMigrationSession session = new MigrationTrigger.MyMigrationSession(update, migrate);
    final MigrationWizard wizard = new MigrationWizard(myProject, session);
    boolean finished = wizard.showAndGet();
    final MigrationError errors = session.getError();
    if (!(finished) && errors == null) {
      // user has postponed migration 
      return;
    }

    resetMigrationQueuedFlag();

    if (errors == null) {
      ApplicationManager.getApplication().runWriteAction(new Runnable() {
        public void run() {
          ProjectManagerEx.getInstance().reloadProject(myProject);
        }
      });
    } else {
      StartupManager.getInstance(myProject).runWhenProjectIsInitialized(new Runnable() {
        public void run() {
          final Wrappers._T<List<IssueKindReportItem>> problems = new Wrappers._T<List<IssueKindReportItem>>();
          ProgressManager.getInstance().run(new Task.Modal(myProject, "Collecting Errors", false) {
            public void run(@NotNull final ProgressIndicator progressIndicator) {
              myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
                public void run() {
                  problems.value = ListSequence.fromListWithValues(new ArrayList<IssueKindReportItem>(), errors.getProblems(progressIndicator));
                }
              });
            }
          });
          ApplicationManager.getApplication().invokeLater(new Runnable() {
            public void run() {
              myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
                public void run() {
                  myProject.getComponent(MigrationProblemHandler.class).showProblems(problems.value);
                }
              });
            }
          }, ModalityState.NON_MODAL);
        }
      });
    }
  }

  private void syncRefresh() {
    final Application application = ApplicationManager.getApplication();
    WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {
      public void run() {
        application.saveAll();
      }
    });
    VirtualFileUtils.refreshSynchronouslyRecursively(myProject.getBaseDir(), new EmptyProgressMonitor());
    WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {
      public void run() {
        myReloadManager.flush();
      }
    });
  }

  private class MyReloadListener implements ReloadListener {
    private boolean myUnderReload = false;
    @Override
    public void reloadStarted() {
      myUnderReload = true;
    }
    @Override
    public void reloadFinished() {
      myUnderReload = false;
    }
    public boolean isIsUnderReload() {
      return myUnderReload;
    }
  }

  private boolean isProjectMigrateableModule(@NotNull SModule module) {
    return myMpsProject.getProjectModulesWithGenerators().contains(module) && MigrationModuleUtil.isModuleMigrateable(module);
  }

  private class MyRepoListener extends SRepositoryContentAdapter {
    private class ModuleBatchUpdater implements Runnable {
      public Set<SModule> modulesTouched = SetSequence.fromSet(new HashSet<SModule>());
      private boolean touchedUnderReload = false;
      public void run() {
        myTask = null;
        List<SModule> toUpdate = SetSequence.fromSet(modulesTouched).distinct().where(new IWhereFilter<SModule>() {
          public boolean accept(SModule it) {
            return isProjectMigrateableModule(it);
          }
        }).toListSequence();
        if (!(touchedUnderReload)) {
          for (SModule m : ListSequence.fromList(toUpdate)) {
            updateSingleModuleDescriptorSilently(m);
          }
        }
        checkMigrationNeededOnModuleChange(toUpdate);
      }
    }
    private MigrationTrigger.MyRepoListener.ModuleBatchUpdater myTask = null;

    private void updateSingleModuleDescriptorSilently(SModule module) {
      if (!(isProjectMigrateableModule(module))) {
        return;
      }
      myMigrationRegistry.doUpdateImportVersions(module);
    }
    private void triggerOnModuleChanged(SModule module) {
      if (myTask == null) {
        myTask = new MigrationTrigger.MyRepoListener.ModuleBatchUpdater();
        myMpsProject.getModelAccess().executeCommandInEDT(myTask);
      }
      SetSequence.fromSet(myTask.modulesTouched).addElement(module);
      if (myReloadListener.isIsUnderReload()) {
        myTask.touchedUnderReload = true;
      }
    }
    private SModelEventVisitor myVisitor = new SModelEventVisitorAdapter() {
      @Override
      public void visitLanguageEvent(SModelLanguageEvent event) {
        updateSingleModuleDescriptorSilently(event.getModel().getModule());
      }
      @Override
      public void visitDevKitEvent(SModelDevKitEvent event) {
        updateSingleModuleDescriptorSilently(event.getModel().getModule());
      }
    };
    private ModelsEventsCollector myModelListener = new ModelsEventsCollector() {
      @Override
      protected void eventsHappened(List<SModelEvent> events) {
        ListSequence.fromList(events).visitAll(new IVisitor<SModelEvent>() {
          public void visit(SModelEvent it) {
            it.accept(myVisitor);
          }
        });
      }
    };
    @Override
    public void moduleAdded(@NotNull SModule module) {
      super.moduleAdded(module);
      // here we do not filter out non-project modules because this method is called from 'New Language' action 
      // before module is attached to project 
      if (MigrationModuleUtil.isModuleMigrateable(module)) {
        triggerOnModuleChanged(module);
      }
    }

    @Override
    public void moduleChanged(@NotNull SModule module) {
      super.moduleChanged(module);
      if (MigrationModuleUtil.isModuleMigrateable(module)) {
        triggerOnModuleChanged(module);
      }
    }
    @Override
    protected void startListening(SModel model) {
      super.startListening(model);
      if (isProjectMigrateableModule(model.getModule())) {
        myModelListener.startListeningToModel(model);
      }
    }
    @Override
    protected void stopListening(SModel model) {
      super.stopListening(model);
      if (isProjectMigrateableModule(model.getModule())) {
        myModelListener.stopListeningToModel(model);
      }
    }
  }

  private class MyClassesListener extends MPSClassesListenerAdapter {
    @Override
    public void afterClassesLoaded(Set<? extends ReloadableModuleBase> modules) {
      // do not hold set of modules from notification, make a local copy 
      final List<Language> list = SetSequence.fromSet(modules).ofType(Language.class).toListSequence();
      if (ListSequence.fromList(list).isEmpty()) {
        return;
      }
      myMpsProject.getModelAccess().runWriteInEDT(new Runnable() {
        public void run() {
          checkMigrationNeededOnLanguageReload(list);
        }
      });
    }
  }

  private class MyPropertiesListener implements ProjectMigrationProperties.MigrationPropertiesReloadListener {
    @Override
    public void onReload() {
      checkMigrationNeeded();
    }
  }

  private class MyMigrationSession extends MigrationSession.MigrationSessionBase {
    private MigrationCheckerImpl myChecker;
    private MigrationExecutorImpl myExecutor;
    private Set<MigrationSession.MigrationStepKind> mySteps;

    public MyMigrationSession(boolean resave, boolean migrate) {
      this.myChecker = new MigrationCheckerImpl(myMpsProject, getMigrationRegistry());
      this.myExecutor = new MigrationExecutorImpl(myMpsProject);
      this.mySteps = SetSequence.fromSet(new HashSet<MigrationSession.MigrationStepKind>());
      if (resave) {
        getRequiredSteps().add(MigrationSession.MigrationStepKind.RESAVE);
      }
      if (migrate) {
        getRequiredSteps().add(MigrationSession.MigrationStepKind.MIGRATE);
      }
    }
    @Override
    public jetbrains.mps.project.Project getProject() {
      return myMpsProject;
    }
    @Override
    public MigrationRegistry getMigrationRegistry() {
      return myMigrationRegistry;
    }
    @Override
    public MigrationOptions getOptions() {
      return myOptions;
    }
    @Override
    public MigrationChecker getChecker() {
      return this.myChecker;
    }
    @Override
    public MigrationExecutor getExecutor() {
      return this.myExecutor;
    }
  }
}
