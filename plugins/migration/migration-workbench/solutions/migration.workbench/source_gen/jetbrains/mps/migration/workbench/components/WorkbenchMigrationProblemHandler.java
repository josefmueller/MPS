package jetbrains.mps.migration.workbench.components;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.migration.global.MigrationProblemHandler;
import jetbrains.mps.ide.findusages.view.UsagesViewTool;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerTool;
import jetbrains.mps.project.Project;
import jetbrains.mps.ide.migration.IStartupMigrationExecutor;
import jetbrains.mps.project.MPSProject;
import java.util.Collection;
import jetbrains.mps.errors.item.IssueKindReportItem;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerViewer;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.icons.AllIcons;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import java.util.function.Consumer;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import javax.swing.SwingUtilities;
import jetbrains.mps.ide.save.SaveRepositoryCommand;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.make.MakeServiceComponent;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.resources.MResource;
import org.jetbrains.annotations.NotNull;

public class WorkbenchMigrationProblemHandler extends AbstractProjectComponent implements MigrationProblemHandler {
  private UsagesViewTool myUsagesTool;
  private ModelCheckerTool myMcTool;
  private Project myMpsProject;
  private IStartupMigrationExecutor myMigrationTrigger;

  public WorkbenchMigrationProblemHandler(MPSProject project, IStartupMigrationExecutor migrationTrigger, UsagesViewTool usagesTool, ModelCheckerTool mcTool) {
    super(project.getProject());
    myUsagesTool = usagesTool;
    myMcTool = mcTool;
    myMpsProject = project;
    myMigrationTrigger = migrationTrigger;
  }

  public void showProblems(Collection<IssueKindReportItem> problems) {
    Iterable<SearchResult<IssueKindReportItem>> items = CollectionSequence.fromCollection(problems).select(new ISelector<IssueKindReportItem, SearchResult<IssueKindReportItem>>() {
      public SearchResult<IssueKindReportItem> select(IssueKindReportItem p) {
        return new SearchResult<IssueKindReportItem>(p, IssueKindReportItem.PATH_OBJECT.get(p).resolve(myMpsProject.getRepository()), IssueKindReportItem.FLAVOUR_ISSUE_KIND.get(p));
      }
    }).where(new IWhereFilter<SearchResult<IssueKindReportItem>>() {
      public boolean accept(SearchResult<IssueKindReportItem> it) {
        return it != null;
      }
    });

    if (Sequence.fromIterable(items).isEmpty()) {
      return;
    }

    ModelCheckerViewer v = new ModelCheckerViewer(myProject, false) {
      @Override
      protected void close() {
        myMcTool.closeTab(this);
        super.close();
      }
    };

    final SearchResults<IssueKindReportItem> result = new SearchResults<IssueKindReportItem>();
    Sequence.fromIterable(items).visitAll(new IVisitor<SearchResult<IssueKindReportItem>>() {
      public void visit(SearchResult<IssueKindReportItem> it) {
        result.add(it);
      }
    });
    v.setSearchResults(result);
    myMcTool.showTabWithResults(v, "Migration issues", AllIcons.Nodes.ModuleGroup);
  }

  public void showNodes(final Map<String, Set<SNode>> toShow) {
    final SearchResults<SNode> sr = new SearchResults<SNode>();
    SetSequence.fromSet(MapSequence.fromMap(toShow).keySet()).translate(new ITranslator2<String, SearchResult<SNode>>() {
      public Iterable<SearchResult<SNode>> translate(String k) {
        return SetSequence.fromSet(MapSequence.fromMap(toShow).get(k)).select(new ISelector<SNode, SearchResult<SNode>>() {
          public SearchResult<SNode> select(SNode node) {
            return new SearchResult<SNode>();
          }
        });
      }
    }).visitAll(new IVisitor<SearchResult<SNode>>() {
      public void visit(SearchResult<SNode> it) {
        sr.add(it);
      }
    });
    myUsagesTool.show(sr, "No results to show");
  }

  @Override
  public void projectOpened() {
  }
  @Override
  public void projectClosed() {
  }
  @Override
  public void initComponent() {
    myMigrationTrigger.setRebuildHandler(new Consumer<Iterable<SModuleReference>>() {
      public void accept(final Iterable<SModuleReference> modules) {
        final SRepository repo = myMpsProject.getRepository();
        repo.getModelAccess().runWriteAction(new Runnable() {
          public void run() {
            final List<SModel> modelsToClean = Sequence.fromIterable(modules).translate(new ITranslator2<SModuleReference, SModel>() {
              public Iterable<SModel> translate(SModuleReference it) {
                return it.resolve(repo).getModels();
              }
            }).where(new IWhereFilter<SModel>() {
              public boolean accept(SModel it) {
                return GenerationFacade.canGenerate(it);
              }
            }).toListSequence();
            myMpsProject.getComponent(ModelGenerationStatusManager.class).discard(modelsToClean);

            // todo the following is copied from MakeActionImpl, it's better to make MAI to be compilied in Idea  
            // todo (and contributed by xml); this code should use idea-compiled class then 
            SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                // save all before launching make 
                new SaveRepositoryCommand(myMpsProject.getRepository()).execute();
                MakeSession session = new MakeSession(myMpsProject, new DefaultMakeMessageHandler(myMpsProject), false);
                final IMakeService makeService = myMpsProject.getComponent(MakeServiceComponent.class).get();
                if (makeService.openNewSession(session)) {
                  final List<IResource> inputRes = ListSequence.fromList(new ArrayList<IResource>());
                  repo.getModelAccess().runReadAction(new Runnable() {
                    public void run() {
                      ListSequence.fromList(inputRes).addSequence(ListSequence.fromList(modelsToClean).select(new ISelector<SModel, SModule>() {
                        public SModule select(SModel it) {
                          return it.getModule();
                        }
                      }).distinct().select(new ISelector<SModule, MResource>() {
                        public MResource select(final SModule module) {
                          return new MResource(module, ListSequence.fromList(modelsToClean).where(new IWhereFilter<SModel>() {
                            public boolean accept(SModel model) {
                              return model.getModule() == module;
                            }
                          }));
                        }
                      }));
                    }
                  });
                  if (inputRes != null) {
                    makeService.make(session, inputRes);
                  } else {
                    makeService.closeSession(session);
                  }
                }
              }
            });
          }
        });
      }
    });
  }
  @Override
  public void disposeComponent() {
    myMigrationTrigger.setRebuildHandler(null);
  }
  @Override
  @NotNull
  public String getComponentName() {
    return this.getClass().getSimpleName();
  }
}
