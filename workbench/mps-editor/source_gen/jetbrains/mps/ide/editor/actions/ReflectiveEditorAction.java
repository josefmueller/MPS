package jetbrains.mps.ide.editor.actions;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.openapi.editor.EditorComponent;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.ArrayList;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.function.Predicate;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.reflectiveEditor.ReflectiveHintsManager;

/*package*/ class ReflectiveEditorAction {
  private final List<ReflectiveEditorAction.ReflectiveHintsAction> myActions;
  private final EditorComponent myEditorComponent;
  private final boolean myIsReflective;
  private final boolean myIsForSubtree;
  private List<List<SNode>> mySelectionStack = new ArrayList<List<SNode>>();

  /*package*/ ReflectiveEditorAction(List<SNode> affectedNodes, EditorComponent editorComponent, boolean isReflective, boolean isForSubtree) {
    if (!(isForSubtree) && !(isReflective)) {
      throw new IllegalArgumentException("showing regular editor for node is not supported");
    }
    myEditorComponent = editorComponent;
    myIsReflective = isReflective;
    myIsForSubtree = isForSubtree;
    myActions = affectedNodes.stream().map(new Function<SNode, ReflectiveEditorAction.ReflectiveHintsAction>() {
      public ReflectiveEditorAction.ReflectiveHintsAction apply(SNode node) {
        return getAction(node);
      }
    }).collect(Collectors.<ReflectiveEditorAction.ReflectiveHintsAction>toList());
  }
  @NotNull
  private ReflectiveEditorAction.ReflectiveHintsAction getAction(SNode node) {
    if (myIsForSubtree) {
      return new ReflectiveEditorAction.MakeSubtreeAction(node);
    } else {
      return new ReflectiveEditorAction.MakeNodeReflectiveAction(node);
    }
  }
  /*package*/ void update(AnActionEvent event) {
    boolean canMake = myActions.stream().anyMatch(new Predicate<ReflectiveEditorAction.ReflectiveHintsAction>() {
      public boolean test(ReflectiveEditorAction.ReflectiveHintsAction action) {
        return action.isApplicable();
      }
    }) && !((myActions.size() > 1 && !(myIsForSubtree)));
    if (canMake) {
      String plurality = ((myIsForSubtree ? "s for Subtree" : "")) + ((myActions.size() > 1 ? "s" : ""));
      String caption = String.format("Show %s Editor%s", (myIsReflective ? "Reflective" : "Regular"), plurality);
      event.getPresentation().setText(caption);
      event.getPresentation().setVisible(true);
      event.getPresentation().setEnabled(true);
    } else {
      event.getPresentation().setVisible(false);
      event.getPresentation().setEnabled(false);
    }
  }
  private void recordSelectionStack() {
    SelectionManager selectionManager = myEditorComponent.getEditorContext().getSelectionManager();
    for (Selection selection : selectionManager.getSelectionStackIterable()) {
      if (mySelectionStack.isEmpty() || !(selection.getSelectedNodes().equals(mySelectionStack.get(mySelectionStack.size() - 1)))) {
        mySelectionStack.add(selection.getSelectedNodes());
      }
    }
  }
  private void restoreSelectionStack() {
    SelectionManager selectionManager = myEditorComponent.getEditorContext().getSelectionManager();
    selectionManager.clearSelection();
    for (List<SNode> selection : mySelectionStack) {
      if (selection.size() > 1) {
        Selection rangeSelection = selectionManager.createRangeSelection(selection.get(0), selection.get(selection.size() - 1));
        selectionManager.pushSelection(rangeSelection);
      } else {
        EditorCell nodeCell = myEditorComponent.findNodeCell(selection.get(0));
        if (nodeCell.isSelectable()) {
          selectionManager.pushSelection(selectionManager.createSelection(nodeCell));
        }
      }
    }
  }
  private void redraw() {
    myEditorComponent.rebuildEditorContent();
    myEditorComponent.getEditorContext().flushEvents();
  }
  private void doExecute() {
    for (ReflectiveEditorAction.ReflectiveHintsAction action : myActions) {
      if (action.isApplicable()) {
        action.execute();
      }
    }
  }
  /*package*/ void execute() {
    recordSelectionStack();
    doExecute();
    redraw();
    restoreSelectionStack();
  }
  private abstract class ReflectiveHintsAction {
    protected final SNode myNode;
    private ReflectiveHintsAction(SNode node) {
      myNode = node;
    }
    /*package*/ abstract boolean isApplicable();
    /*package*/ abstract void execute();
  }
  /*package*/ class MakeNodeReflectiveAction extends ReflectiveEditorAction.ReflectiveHintsAction {
    private MakeNodeReflectiveAction(SNode node) {
      super(node);
    }
    @Override
    /*package*/ boolean isApplicable() {
      return ReflectiveHintsManager.canMakeNodeReflective(myNode, myEditorComponent);
    }
    @Override
    /*package*/ void execute() {
      ReflectiveHintsManager.makeNodeReflective(myNode, myEditorComponent);
    }
  }
  /*package*/ class MakeSubtreeAction extends ReflectiveEditorAction.ReflectiveHintsAction {
    /*package*/ MakeSubtreeAction(SNode node) {
      super(node);
    }
    @Override
    /*package*/ boolean isApplicable() {
      return ReflectiveHintsManager.canMakeSubtree(myNode, myEditorComponent, myIsReflective);
    }
    @Override
    /*package*/ void execute() {
      ReflectiveHintsManager.makeSubtree(myNode, myEditorComponent, myIsReflective);
    }
  }

}
